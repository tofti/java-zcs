package com.tofti.zcs;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

public class ZCS {

    public static final double ZERO_STRENGTH = 1E-6;

    public ZCSClassifierSet getClassifierPopulation() {
        return population;
    }

    private interface ZCSLog {
        void log(String s);
        void finalise();
    }

    private final class ZCSFileLog implements ZCSLog {
        private BufferedWriter out;

        public ZCSFileLog() {
            try {
                String filename = ZCSUtility.getFileName("zcs") + ".txt";
                out = new BufferedWriter(new FileWriter(filename));
            }
            catch (IOException e) {
                System.err.print(e);
                e.printStackTrace();
            }
        }

        public void log(String s) {
            try {
                out.write(s);
                out.newLine();
                out.flush();
            }
            catch (IOException e) {
                System.err.print(e);
                e.printStackTrace();
            }
        }

        public void finalise() {
            try {
                out.flush();
                out.close();
            }
            catch (IOException e) {
                System.err.print(e);
                e.printStackTrace();
            }
        }
    }

    private final class ZCSNoLog implements ZCSLog {
        public void log(String s) {}
        public void finalise() {}
        public void flush() {}
    }

    static Random RAND;
    static {
        RAND = new Random();
    }
    static double nextDouble() {
        return RAND.nextDouble();
    }

    private ZCSClassifierSet population;

    // current timestep action set [A]
    private ZCSClassifierSet actionSet;

    // previous timestep action set [A_-1]
    private ZCSClassifierSet prevActionSet;

    // classifier condition length
    private final int cLength;

    // classifier action length
    private final int aLength;

    // p the probability of a '#' appearing in a condition
    // string generated by the initialization or covering operator
    private final double p;

    // initial strength of generated classifiers
    private final double s;

    // population size
    private int n;

    // bucket co-efficient for [A]
    private final double beta;

    // discount co-efficient for [A_-1]
    private final double gamma;

    // taxation for classifiers in [M] - [A]
    private final double tau;

    // probability of crossover per GA invocation
    private final double chi;

    // probability of mutation per allele in offspring
    private final double mu;

    // the average number of new classifiers generated by the ga
    // per timestep of the performance cycle
    private double rho;

    // covering threshold
    private double phi;

    // the log
    private ZCSLog log;

    // do we want the ZCS to initialise its population?
    private boolean initialisePopulation;

    // ZCS statistics
    private int gaInvocations;
    private int coveringInvocations;

    public ZCS(int cLength, int aLength, int n, double p,
               double s, double beta, double gamma, double tau,
               double chi, double mu, double rho, double phi,
               boolean initialisePopulation, boolean debugZCS) {

        this.cLength = cLength;
        this.aLength = aLength;
        this.n = n;
        this.p = p;
        this.s = s;
        this.beta = beta;
        this.gamma = gamma;
        this.tau = tau;
        this.chi = chi;
        this.mu = mu;
        this.rho = rho;
        this.phi = phi;

        this.initialisePopulation = initialisePopulation;

        if(debugZCS) {
            log = new ZCSFileLog();
        } else {
            log = new ZCSNoLog();
        }

        // initialise the ZCS
        init(initialisePopulation);
        log.log("[P_1]=\n" + population);
    }

    // generate an initial population
    private void init(boolean initialisePopulation) {
        ZCSClassifierSet initialPopulation = new ZCSClassifierSet();

        if(initialisePopulation) {
            log.log("Initialising Population!");
            for(int i = 0; i < n; i++) {
                initialPopulation.addClassifier(ZCSClassifier.generateClassifier(cLength, aLength, s, p));
            }
        }
        setPopulation(initialPopulation);
        actionSet = new ZCSClassifierSet();
        prevActionSet = new ZCSClassifierSet();

        gaInvocations = 0;
        coveringInvocations = 0;
    }

    public void addClassifier(char[] condition, char[] action, double strength) {
        population.addClassifier(ZCSClassifier.generateClassifier(condition, action, strength));
    }

    public void addClassifier(String condition, String action, double strength) {
        addClassifier(condition.toCharArray(), action.toCharArray(), strength);
    }

    public void reset() {
        log.log("[P_final]=\n" + population);
        init(initialisePopulation);
    }

    private void setPopulation(ZCSClassifierSet population) {
        this.population = population;
    }

    public void clearPreviousActionSet() {
        prevActionSet.clearSet();
    }

    public void finalise() {
        log.finalise();
    }

    public void reward(double r) {
        log.log("...rewarding(" + r + ") classifiers in the current action set.");
        log.log(actionSet.toString());
        // add strength beta * r / |[A]| to each classifier in [A]
        double currentActionSetReward = (beta * r) / actionSet.size();
        actionSet.getClassifiers().stream().forEach( c-> c.increaseStrength(currentActionSetReward));
    }

    public char[] classify(String input) {
        return classify(input.toCharArray());
    }

    // the agent pushes the binary coded sensed environment data onto the ZCS
    public char[] classify(char[] input) {
        log.log("------------------------------TIMESTEP--------------------------");
        log.log("GA Invocations " + gaInvocations);
        log.log("Covering Invocations " + coveringInvocations);

        //String action = (isExplore) ? "exploring" : "exploiting";
        //log.log("\n\nClassifier system is " + action + " and detected " + String.valueOf(input));
        log.log("\n\nClassifier system detected " + String.valueOf(input));
        log.log("[P]=\n" + population);

        // determine the match set
        ZCSClassifierSet matchset = getMatchSet(population, input);
        log.log("\nFormed a match set [M]=\n" + matchset);

        // covering occurs
        if(matchset.isEmpty() || matchset.getSumStrength() < phi * population.getMeanStrength()) {
            log.log("...covering occurs");
            // do some covering operation
            coveringOperator(population, aLength, input, p);
            // form a new matchset
            matchset = getMatchSet(population, input);
            log.log("\nFormed a new match set [M]=\n" + matchset);
        }

        // roulette wheel selection to find active classifier
        ZCSClassifier activeClassifier = getRouletteSelectedClassifier(matchset);

        log.log("activeClassifier=\n" + activeClassifier);

        // set [A_-1] = [A]
        prevActionSet = actionSet;

        // generate a new action set of classifiers with the same
        // action as the selected classifier
        actionSet = getActionSet(matchset, activeClassifier);
        log.log("\nFormed an action set [A]=\n" + actionSet);

        // create a bucket
        double bucket = getBucketValue(actionSet, beta);
        log.log("Current action set bucket = " + bucket);

        // add strength gamma * bucket / |[A_-1]| to each classifier in [A_-1]
        log.log("...reinforcing classifiers from previous action set.");
        double prevActionSetReward = (gamma * bucket) / prevActionSet.size();

        prevActionSet.getClassifiers().stream().forEach(c -> c.increaseStrength(prevActionSetReward));

        // taxation of classifiers in [M] - [A]
        ZCSClassifierSet taxSet = matchset.setMinus(actionSet);
        log.log("...taxing classifiers in [T]=\n" + taxSet);
        taxClassifiers(taxSet, tau);
        log.log("\n...after tax [T]=\n" + taxSet);

        if(RAND.nextDouble() < rho) {
            // invoke the GA
            log.log("GA invoked...");
            // panmictic GA
            geneticAlgorithm(population, chi, mu, log);
            gaInvocations++;
        }

        return activeClassifier.getAction();
    }

    // steady state GA
    public static void geneticAlgorithm(ZCSClassifierSet population, double chi, double mu, ZCSLog log) {
        population.getClassifiers().removeIf(c -> c.getStrength() < ZERO_STRENGTH);

        // remove weakest from population first
        ZCSClassifier r1 = getInverseRouletteSelectedClassifier(population);
        population.removeClassifier(r1);
        ZCSClassifier r2 = getInverseRouletteSelectedClassifier(population);
        population.removeClassifier(r2);

        // get two roulette wheel selected classifiers
        ZCSClassifier mom = getRouletteSelectedClassifier(population);
        ZCSClassifier dad = getRouletteSelectedClassifier(population);

        // these classifiers have half of their parents strength
        ZCSClassifier childA = mom.cloneClassifier();
        ZCSClassifier childB = dad.cloneClassifier();

        log.log("ChildA : " + childA);
        log.log("ChildB : " + childB);

        // crossover chi
        if(RAND.nextDouble() < chi) {
            log.log("Crossover occurs...");
            ZCSClassifier.crossoverClassifiers(childA, childB);
            log.log("ChildA : " + childA);
            log.log("ChildB : " + childB);
        }

        // mutation mu
        ZCSClassifier.mutateClassifier(childA, mu);
        ZCSClassifier.mutateClassifier(childB, mu);

        log.log("Children after mutation...");
        log.log("ChildA : " + childA);
        log.log("ChildB : " + childB);

        log.log("RemovedClassifier1 : " + r1);
        log.log("RemovedClassifier2 : " + r2);

        // add children to population
        population.addClassifier(childA);
        population.addClassifier(childB);
    }

    // generate a match set
    public static ZCSClassifierSet getMatchSet(final ZCSClassifierSet population, final char[] input) {
        return new ZCSClassifierSet(
            population.getClassifiers().stream()
                                       .filter(c -> c.isConditionMatched(input))
                                       .collect(Collectors.toSet())
        );
    }

    public static void coveringOperator(ZCSClassifierSet population, int aLength, char[] input, double p) {
        // remove a weak classifier
        ZCSClassifier removedClassifier = getInverseRouletteSelectedClassifier(population);
        population.removeClassifier(removedClassifier);

        // perform a covering operation
        double avgPopulationStrength = population.getMeanStrength();
        ZCSClassifier coveringClassifier = ZCSClassifier.generateCoveringClassifier(input, aLength, avgPopulationStrength, p);
        population.addClassifier(coveringClassifier);

    }

    public static ZCSClassifier getRouletteSelectedClassifier(ZCSClassifierSet classifierSet) {
        double rouletteStrength = classifierSet.getSumStrength() * RAND.nextDouble();
        double accumulatedStrength = 0.0;
        for (ZCSClassifier classifier : classifierSet.getClassifiers()) {
            accumulatedStrength = accumulatedStrength + classifier.getStrength();
            if(rouletteStrength < accumulatedStrength) {
                return classifier;
            }
        }
        throw new IllegalStateException(String.format("Roulette wheel for %s is malformed", classifierSet));
    }

    // as above but works on the inverse of the classifier strength
    public static ZCSClassifier getInverseRouletteSelectedClassifier(ZCSClassifierSet classifierSet) {
        double rouletteStrength = classifierSet.getSumInverseStrength() * RAND.nextDouble();
        double accumulatedInverseStrength = 0.0;
        for (ZCSClassifier classifier : classifierSet.getClassifiers()) {
            accumulatedInverseStrength = accumulatedInverseStrength + classifier.getInverseStrength();
            if(rouletteStrength < accumulatedInverseStrength) {
                return classifier;
            }
        }
        throw new IllegalStateException(String.format("Roulette wheel for %s is malformed", classifierSet));
    }

    // return a subset of matchset classifiers which advocate the same action as the activated classifier
    public static ZCSClassifierSet getActionSet(final ZCSClassifierSet matchset, final ZCSClassifier activeClassifier) {
        ZCSClassifierSet actionset = new ZCSClassifierSet();
        for (ZCSClassifier classifier : matchset.getClassifiers()) {
            // the match set classifier advocates the same action
            if(activeClassifier.isActionMatched(classifier)) {
                actionset.addClassifier(classifier);
            }
        }
        return actionset;
    }

    public static double getBucketValue(ZCSClassifierSet actionset, double beta) {
        double bucketValue = 0.0;
        for (ZCSClassifier classifier : actionset.getClassifiers()) {
            bucketValue = bucketValue + classifier.getActionSetPayment(beta);
        }
        return bucketValue;
    }

    public static void taxClassifiers(ZCSClassifierSet taxset, double tau) {
        taxset.getClassifiers().stream().forEach(c -> c.tax(tau));
    }
}